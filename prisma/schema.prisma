generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// User role enum
enum Role {
  USER
  ADMIN
}

// User model for authentication and core data
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String // Hashed password
  name      String?
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Verification & Trust
  emailVerified   Boolean   @default(false)
  phoneVerified   Boolean   @default(false)
  photoVerified   Boolean   @default(false)
  idVerified      Boolean   @default(false)
  trustScore      Int       @default(0)
  accountStatus   String    @default("LIMITED") // LIMITED, VERIFIED, BANNED, ENGAGED
  verificationOTP String?
  otpExpires      DateTime?

  // Proposals
  proposalsSent     Proposal[] @relation("ProposalsSent")
  proposalsReceived Proposal[] @relation("ProposalsReceived")

  // Family Management
  managedById String?
  managedBy   User?   @relation("Manager", fields: [managedById], references: [id])
  manages     User[]  @relation("Manager")

  // Relations
  profile           Profile?
  sentInterests     Interest[] @relation("SentInterests")
  receivedInterests Interest[] @relation("ReceivedInterests")

  // Matching and Social
  sentMatches     Match[] @relation("Sender")
  receivedMatches Match[] @relation("Receiver")

  // Chat
  sentMessages     Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")

  // Favorites
  favorites   Favorite[] @relation("UserFavorites")
  favoritedBy Favorite[] @relation("UserFavoritedBy")

  // Notifications
  notifications Notification[]

  // Verification Logs
  verificationLogs VerificationLog[]

  blocksSent     Block[] @relation("Blocker")
  blocksReceived Block[] @relation("Blocked")

  identityDocuments IdentityDocument[]

  @@map("users")
}

enum ProposalAnswer {
  YES
  NO
  PENDING
}

model Proposal {
  id          String   @id @default(uuid())
  proposerId  String
  recipientId String
  answer      String   @default("PENDING") // YES, NO, PENDING
  message     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Explicit relation names
  proposer  User @relation("ProposalsSent", fields: [proposerId], references: [id])
  recipient User @relation("ProposalsReceived", fields: [recipientId], references: [id])

  @@index([proposerId])
  @@index([recipientId])
  @@map("proposals")
}

// Interest Request System (Step 5) - Canonical source of truth
model Interest {
  id         String   @id @default(uuid())
  senderId   String
  receiverId String
  status     String   @default("PENDING") // PENDING, ACCEPTED, REJECTED, WITHDRAWN
  message    String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  sender   User @relation("SentInterests", fields: [senderId], references: [id])
  receiver User @relation("ReceivedInterests", fields: [receiverId], references: [id])

  @@unique([senderId, receiverId])
  @@index([senderId, createdAt])
  @@map("interests")
}

// Verification Log System (Step 3)
model VerificationLog {
  id        String   @id @default(uuid())
  userId    String
  type      String // EMAIL, PHONE, PHOTO, ID
  status    String // PENDING, VERIFIED, REJECTED
  details   String?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("verification_logs")
}

// Notification model for in-app and browser notifications
model Notification {
  id        String   @id @default(uuid())
  userId    String
  type      String // MESSAGE, PROPOSAL, PROPOSAL_ACCEPTED, PROPOSAL_REJECTED, FAVORITE, INTEREST, SYSTEM
  title     String
  message   String
  link      String? // Navigation link when clicked
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}

// Favorite connection
model Favorite {
  id          String @id @default(uuid())
  userId      String // The user who favorited
  favoritedId String // The user who was favorited

  user      User @relation("UserFavorites", fields: [userId], references: [id])
  favorited User @relation("UserFavoritedBy", fields: [favoritedId], references: [id])

  createdAt DateTime @default(now())

  @@unique([userId, favoritedId])
  @@map("favorites")
}

// Detailed User Profile for Discovery (Step 2)
model Profile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Logic & Completion
  completeness Int @default(0) // 0-100 percentage

  // Vital Stats (Step 2.1)
  dateOfBirth  DateTime?
  age          Int
  gender       String
  height       Float? // In cm
  religion     String?
  caste        String?
  motherTongue String?
  bio          String
  location     String

  // Lifestyle (Step 2.2)
  jobStatus      String // e.g., "EMPLOYED", "UNEMPLOYED", "STUDENT"
  maritalStatus  String // e.g., "SINGLE", "WIDOWED", "DIVORCED"
  education      String?
  profession     String?
  incomeRange    String?
  diet           String?
  smoking        String?
  drinking       String?
  jobCategory    String?
  contactDetails String?

  // Family Details (Step 2.3)
  fatherOccupation String?
  motherOccupation String?
  siblings         String?
  familyType       String? // TRADITIONAL, MODERN

  // Partner Preferences (Step 2.4)
  prefAgeMin    Int?
  prefAgeMax    Int?
  prefHeightMin Float?
  prefReligion  String?
  prefEducation String?
  prefLifestyle String?

  // Media
  photoUrl     String
  coverUrl     String?
  photoGallery String? // Comma-separated

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("profiles")
}

// Match connection between two users (Step 8) - Result of successful Interest
model Match {
  id      String @id @default(uuid())
  userAId String
  userBId String

  userA User @relation("Sender", fields: [userAId], references: [id])
  userB User @relation("Receiver", fields: [userBId], references: [id])

  messages Message[]

  createdAt DateTime @default(now())

  @@unique([userAId, userBId])
  @@map("matches")
}

// Real-time Chat Messages
model Message {
  id         String @id @default(uuid())
  content    String
  senderId   String
  receiverId String
  matchId    String

  sender   User  @relation("SentMessages", fields: [senderId], references: [id])
  receiver User  @relation("ReceivedMessages", fields: [receiverId], references: [id])
  match    Match @relation(fields: [matchId], references: [id])

  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([matchId, createdAt])
  @@map("messages")
}

model Block {
  id        String   @id @default(uuid())
  blockerId String
  blockedId String
  reason    String?
  createdAt DateTime @default(now())

  blocker User @relation("Blocker", fields: [blockerId], references: [id])
  blocked User @relation("Blocked", fields: [blockedId], references: [id])

  @@unique([blockerId, blockedId])
  @@map("blocks")
}

// Identity Verification Documents (Step 3)
model IdentityDocument {
  id              String   @id @default(uuid())
  userId          String
  type            String // PASSPORT, AADHAAR, DRIVING_LICENSE, etc.
  fileUrl         String // Internal path or secure URL
  status          String   @default("PENDING") // PENDING, VERIFIED, REJECTED
  rejectionReason String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("identity_documents")
}
